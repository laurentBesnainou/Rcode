{
    "collab_server" : "",
    "contents" : "#Données globales\nlibrary(shiny)\nlibrary(shinyBS)\nlibrary(shinyLP)\nlibrary(shinythemes)\nlibrary(shinydashboard)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(highcharter) # courbe de comparaison des CA de 2015 à 2017\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(RColorBrewer) #coulors pour ggplot\nlibrary(lubridate)\nlibrary(modelr)\nlibrary(splines)\nlibrary(tidyverse)\n\n\n#chargement des données\nload(\"data/pilotage2016_data.RData\")\nload(\"data/pilotage2015_data.RData\")\n\n#données 2017\nload(\"data/pilotage_data.RData\")\nload(\"data/staffing2017.RData\")\nnbJourMois <- c( 22,20,23,19,20,21,20,22,21,22,21,20,22,20,22)\npilotage_2017 <- pilotage_data\n\nObjectif_BT <- 11120\n\n#lissage de l'objectif\nobjectif_Vente <- c(638,\t1276,\t1914,\t2552,\t3190,\t3625,\t4060,\t4495,\t4930,\t5133,\t5336,\t5539,\n  5742,\t5945,\t6307,\t6670,\t7032,\t7395,\t7503,\t7612,\t7721,\t7830,\t8033,\t8236,\n  8439,\t8642,\t8845,\t9062,\t9280,\t9497,\t9715,\t9918,\t10121,\t10324,\t10527,\t10730,\t\n  11128,\t11527,\t11926,\t12325,\t12615,\t12905,\t13195,\t13485,\t13659,\t13833,\n  14007,\t14181,\t14355,\t14451,\t14548,\t14645)\n\nobjectif_Prod <- c(528,\t1056,\t1584,\t2112,\t2640,\t3000,\t3360,\t3720,\t4080,\t4248,\t4416,\t4584,\n                  4752,\t4920,\t5220,\t5520,\t5820,\t6120,\t6210,\t6300,\t6390,\t6480,\t6648,\t6816,\n                  6984,\t7152,\t7320,\t7500,\t7680,\t7860,\t8040,\t8208,\t8376,\t8544,\t8712,\t8880,\n                  9210,\t9540,\t9870,\t10200,\t10440,\t10680,\t10920,\t11160,\t11304,\t11448,\n                  11592,\t11736,\t11880,\t11960,\t12040,\t12120)\n\n\n################ on calcul les nombre de jours\n\n#Calcul des effectifs moyens sur le mois\nnbM1 <- Staffing %>% filter (TYPE == 0, !is.na(JANV)) %>% group_by(GRADE) %>% count(GRADE) %>% mutate(MOIS = \"JANV\")\nnbM2 <- Staffing %>% filter (TYPE == 0, !is.na(FEV)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"FEV\")\nnbM3 <- Staffing %>% filter (TYPE == 0, !is.na(MAR)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"MAR\")\nnbM4 <- Staffing %>% filter (TYPE == 0, !is.na(AVR)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"AVR\")\nnbM5 <- Staffing %>% filter (TYPE == 0, !is.na(MAI)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"MAI\")\nnbM6 <- Staffing %>% filter (TYPE == 0, !is.na(JUIN)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"JUIN\")\nnbM7 <- Staffing %>% filter (TYPE == 0, !is.na(JUIL)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"JUIL\")\nnbM8 <- Staffing %>% filter (TYPE == 0, !is.na(AOUT)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"AOUT\")\nnbM9 <- Staffing %>% filter (TYPE == 0, !is.na(SEPT)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"SEPT\")\nnbM10 <- Staffing %>% filter (TYPE == 0, !is.na(OCT)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"OCT\")\nnbM11 <- Staffing %>% filter (TYPE == 0, !is.na(NOV)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"NOV\")\nnbM12 <- Staffing %>% filter (TYPE == 0, !is.na(DEC)) %>% group_by(GRADE) %>% count(GRADE)  %>% mutate(MOIS = \"DEC\")\n#CALCUL DU NOMBRE DE JOURS MAX POSSIBLE\nnbM1$volume <- nbM1$n * nbJourMois[1] \nnbM2$volume <- nbM2$n * nbJourMois[2] \nnbM3$volume <- nbM3$n * nbJourMois[3] \nnbM4$volume <- nbM4$n * nbJourMois[4] \nnbM5$volume <- nbM5$n * nbJourMois[5] \nnbM6$volume <- nbM6$n * nbJourMois[6] \nnbM7$volume <- nbM7$n * nbJourMois[7] \nnbM8$volume <- nbM8$n * nbJourMois[8] \nnbM9$volume <- nbM9$n * nbJourMois[9] \nnbM10$volume <- nbM10$n * nbJourMois[10] \nnbM11$volume <- nbM11$n * nbJourMois[11] \nnbM12$volume <- nbM12$n * nbJourMois[12] \n\n\nnbEffecti <- rbind(nbM1, nbM2, nbM3, nbM4, nbM5, nbM6, nbM7, nbM8, nbM9, nbM10, nbM11, nbM12)\n\n#on calcul le nombre de jours vendus par grade et par mois  FERME\nnbF1 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(JANV,na.rm =TRUE )) %>% mutate(MOIS = \"JANV\")\nnbF2 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(FEV,na.rm =TRUE )) %>% mutate(MOIS = \"FEV\")\nnbF3 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(MAR,na.rm =TRUE )) %>% mutate(MOIS = \"MAR\")\nnbF4 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(AVR,na.rm =TRUE ))  %>% mutate(MOIS = \"AVR\")\nnbF5 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(MAI,na.rm =TRUE )) %>% mutate(MOIS = \"MAI\")\nnbF6 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(JUIN,na.rm =TRUE ))  %>% mutate(MOIS = \"JUIN\")\nnbF7 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(JUIL,na.rm =TRUE ))  %>% mutate(MOIS = \"JUIL\")\nnbF8 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(AOUT,na.rm =TRUE )) %>% mutate(MOIS = \"AOUT\")\nnbF9 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(SEPT,na.rm =TRUE )) %>% mutate(MOIS = \"SEPT\")\nnbF10 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(OCT,na.rm =TRUE )) %>% mutate(MOIS = \"OCT\")\nnbF11 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(NOV,na.rm =TRUE )) %>% mutate(MOIS = \"NOV\")\nnbF12 <- Staffing %>% filter (TYPE ==1) %>% group_by(GRADE) %>% summarise(nb = sum(DEC,na.rm =TRUE )) %>% mutate(MOIS = \"DEC\")\nnbFERME <- rbind(nbF1, nbF2, nbF3, nbF4, nbF5, nbF6, nbF7, nbF8, nbF9, nbF10, nbF11, nbF12)\n\n#on calcul le nombre de jours vendus par grade et par mois  FERME\nnbF1 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(JANV,na.rm =TRUE )) %>% mutate(MOIS = \"JANV\")\nnbF2 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(FEV,na.rm =TRUE )) %>% mutate(MOIS = \"FEV\")\nnbF3 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(MAR,na.rm =TRUE )) %>% mutate(MOIS = \"MAR\")\nnbF4 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(AVR,na.rm =TRUE ))  %>% mutate(MOIS = \"AVR\")\nnbF5 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(MAI,na.rm =TRUE )) %>% mutate(MOIS = \"MAI\")\nnbF6 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(JUIN,na.rm =TRUE ))  %>% mutate(MOIS = \"JUIN\")\nnbF7 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(JUIL,na.rm =TRUE ))  %>% mutate(MOIS = \"JUIL\")\nnbF8 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(AOUT,na.rm =TRUE )) %>% mutate(MOIS = \"AOUT\")\nnbF9 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(SEPT,na.rm =TRUE )) %>% mutate(MOIS = \"SEPT\")\nnbF10 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(OCT,na.rm =TRUE )) %>% mutate(MOIS = \"OCT\")\nnbF11 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(NOV,na.rm =TRUE )) %>% mutate(MOIS = \"NOV\")\nnbF12 <- Staffing %>% filter (TYPE ==2) %>% group_by(GRADE) %>% summarise(nb = sum(DEC,na.rm =TRUE )) %>% mutate(MOIS = \"DEC\")\nnbPREVI <- rbind(nbF1, nbF2, nbF3, nbF4, nbF5, nbF6, nbF7, nbF8, nbF9, nbF10, nbF11, nbF12)\n\n#on calcul le nombre de jours de congès + inactivité par grade et par mois\nnbC1 <- Staffing %>% filter (TYPE %in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(JANV,na.rm =TRUE )) %>% mutate(MOIS = \"JANV\")\nnbC2 <- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(FEV,na.rm =TRUE )) %>% mutate(MOIS = \"FEV\")\nnbC3 <- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(MAR,na.rm =TRUE )) %>% mutate(MOIS = \"MAR\")\nnbC4 <- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(AVR,na.rm =TRUE ))  %>% mutate(MOIS = \"AVR\")\nnbC5 <- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(MAI,na.rm =TRUE )) %>% mutate(MOIS = \"MAI\")\nnbC6 <- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(JUIN,na.rm =TRUE ))  %>% mutate(MOIS = \"JUIN\")\nnbC7 <- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(JUIL,na.rm =TRUE ))  %>% mutate(MOIS = \"JUIL\")\nnbC8 <- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(AOUT,na.rm =TRUE )) %>% mutate(MOIS = \"AOUT\")\nnbC9<- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(SEPT,na.rm =TRUE )) %>% mutate(MOIS = \"SEPT\")\nnbC10 <- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(OCT,na.rm =TRUE )) %>% mutate(MOIS = \"OCT\")\nnbC11 <- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(NOV,na.rm =TRUE )) %>% mutate(MOIS = \"NOV\")\nnbC12 <- Staffing %>% filter (TYPE%in% c(3,7)) %>% group_by(GRADE) %>% summarise(nb = sum(DEC,na.rm =TRUE )) %>% mutate(MOIS = \"DEC\")\nnbCONGES <- rbind(nbC1, nbC2, nbC3, nbC4, nbC5, nbC6, nbC7, nbC8, nbC9, nbC10, nbC11, nbC12)\n\n\n\n##' Plot flower plot\n##' \n##' @param lengths length of petal outward to extent of circle\n##' @param widths width of petal\n##' @param labels petal label outside of circel\n##' @param disk relative radius of a central donut hole\n##' @param max.length ...\n##' @param center center value\n##' @param main middle value\n##' @param fill.col fill colors\n##' @param plot.outline size of plot outline\n##' @param label.offset label offset\n##' @param xlim formatting\n##' @param ylim formatting\n##' @param uin formatting\n##' @param tol formatting\n##' @param cex size of middle text\n##' @param bty formatting\n##' @param lty line thickness\n##' @param label.col label color\n##' @param label.font label font\n##' @param label.cex size of label text\n##' @return Generate something akin to a rose plot in which the width and\n##' length of each petal are directly specified by the user. Or to put it\n##' differently, this is somewhat like a pie chart in which the radius of each\n##' wedge is allowed to vary (along with the angular width, as pie charts do).\n##' As an additional enhancement, one can specify a central disk of arbitrary\n##' radius (from 0 to 1, assuming that the plot itself is scaled to the unit\n##' circle), in which case the petal heights are always measured from the edge\n##' of the disk rather than the center of the circle; if desired, text can be\n##' added in the center.\n##' \n##' Although this kind of plot may already be well known in some circles (no\n##' pun intended), I haven't seen it clearly defined or labeled anywhere, so\n##' I'm anointing it an 'aster' plot because its component parts are\n##' reminiscent of composite flower morphology.\n##' \n##' The 'lengths' dictates how far out each petal extends, 'widths' dictates\n##' the (angular) width of each petal, and 'disk' gives the relative radius of\n##' a central donut hole. If no widths are provided, all petals will have equal\n##' widths. Additional function arguments can also control whether petals are\n##' labeled, whether the petal lengths are rescaled to the maximum score or to\n##' a user-input score, whether spokes delineating each petal are extended to\n##' an outer circle, and more. I also wrote a quick convenience wrapper for\n##' creating a legend plot.\n##' \n##' Note that the function here is a repurposed and very heavily modified\n##' version of the windrose() function contained in the 'circular' package,\n##' although sufficiently rewritten so as not to depend on any functionality in\n##' that package.\n##' @keywords layers_navigation\n##' @author Created by Jim Regetz. Slight modifications by Darren Hardy and Ben Best.\n##' @examples\n##' \n##' \\dontrun{\n##' # generate some fake data\n##' set.seed(1)\n##' scores <- sample(1:10)\n##' weights <- sample(1:10)\n##' labels <- paste(LETTERS[1:10], \"X\", sep=\"\")\n##' \n##' # do some plots\n##' par(mfrow=c(2,2), xpd=NA)\n##' aster(lengths=scores, widths=weights, disk=0, main=\"Example 1\",\n##'     plot.outline=FALSE)\n##' aster(lengths=scores, widths=weights, labels=labels, main=\"Example 2\",\n##'     lty=2, fill.col=\"gray\", plot.outline=FALSE)\n##' aster.legend(labels=labels, widths=weights)\n##' aster(lengths=scores, widths=weights, disk=0.5, main=\"Example 3\",\n##'     center=\"Hello world\")\n##' }\n##' @import ggplot2\n##' @export\nPlotFlower = function (lengths, widths, labels, disk=0.5, max.length,\n                       center=NULL, main=NULL, fill.col=NULL, plot.outline=TRUE,\n                       label.offset=0.15, xlim=c(-1.2, 1.2), ylim=c(-1.2, 1.2), uin=NULL,\n                       tol=0.04, cex=1, bty=\"n\", lty=1, \n                       label.col='black', label.font=3, label.cex=NULL, ...) {\n  \n  # Custom R function to generate something akin to a rose plot in which\n  # the width and length of each petal are directly specified by the user.\n  # Or to put it differently, this is somewhat like a pie chart in which\n  # the radius of each wedge is allowed to vary (along with the angular\n  # width, as pie charts do). As an additional enhancement, one can\n  # specify a central disk of arbitrary radius (from 0 to 1, assuming that\n  # the plot itself is scaled to the unit circle), in which case the petal\n  # heights are always measured from the edge of the disk rather than the\n  # center of the circle; if desired, text can be added in the center.\n  #\n  # Although this kind of plot may already be well known in some circles\n  # (no pun intended), I haven't seen it clearly defined or labeled\n  # anywhere, so I'm anointing it an 'aster' plot because its component\n  # parts are reminiscent of composite flower morphology.\n  #\n  # As coded below, 'lengths' dictates how far out each petal extends,\n  # 'widths' dictates the (angular) width of each petal, and 'disk' gives\n  # the relative radius of a central donut hole. If no widths are\n  # provided, all petals will have equal widths. Additional function\n  # arguments can also control whether petals are labeled, whether the\n  # petal lengths are rescaled to the maximum score or to a user-input\n  # score, whether spokes delineating each petal are extended to an outer\n  # circle, and more. I also wrote a quick convenience wrapper for\n  # creating a legend plot.\n  #\n  # Note that the function here is a repurposed and very heavily modified\n  # version of the windrose() function contained in the 'circular'\n  # package, although sufficiently rewritten so as not to depend on any\n  # functionality in that package.\n  #\n  # Example invocations appear below.\n  #\n  # Jim Regetz\n  # NCEAS\n  # Created on 13-Sept-2011\n  #\n  # Mods by Ben Best and Darren Hardy\n  # December 2011\n  #  - fix blank hairlines between circles and polygons in pedals\n  #  - accepts more labeling and title options\n  #  - accepts data frames for lengths\n  #\n  # Example plots...\n  #\n  # # generate some fake data\n  # set.seed(1)\n  # scores <- sample(1:10)\n  # weights <- sample(1:10)\n  # labels <- paste(LETTERS[1:10], \"X\", sep=\"\")\n  # \n  # # do some plots\n  # png(file=\"aster-plots.png\", height=600, width=600)\n  # par(mfrow=c(2,2), xpd=NA)\n  # aster(lengths=scores, widths=weights, disk=0, main=\"Example 1\",\n  #     plot.outline=FALSE)\n  # aster(lengths=scores, widths=weights, labels=labels, main=\"Example 2\",\n  #     lty=2, fill.col=\"gray\", plot.outline=FALSE)\n  # aster.legend(labels=labels, widths=weights)\n  # aster(lengths=scores, widths=weights, disk=0.5, main=\"Example 3\",\n  #     center=\"Hello world\")\n  # dev.off()\n  # main aster function definition\n  \n  if (is.data.frame(lengths)) {\n    lengths <- as.numeric(lengths)\n  }\n  n.petals <- length(lengths)\n  if (missing(widths)) {\n    widths <- rep(1, n.petals)\n  }\n  if (missing(max.length)) {\n    max.length <- max(lengths)\n  }\n  if (missing(labels)) {\n    labels <- names(lengths)\n  }\n  if (missing(label.cex)) {\n    label.cex <- 0.7 * cex\n  }  \n  \n  # determine radius of each petal\n  if (disk < 0 || 1 < disk) {\n    stop(\"disk radius must be between 0 and 1\")\n  }\n  radii <- disk + (1-disk) * lengths/max.length\n  \n  # define inner function for drawing circles\n  # (from original windrose function)\n  circles <- function(rad, sector=c(0, 2 * pi), lty=2,\n                      col=\"white\", border=NA, fill=FALSE) {\n    values <- seq(sector[1], sector[2], by=(sector[2] - sector[1])/360)\n    x <- rad * cos(values)\n    y <- rad * sin(values)\n    if (fill) {\n      polygon(x, y, xpd=FALSE, lty=lty, col=col, border=border)\n    }\n    lines(x, y, col=1, lty=lty)\n  }\n  \n  # lots of low-level positional details\n  # (from original windrose function)\n  op <- par(mar=c(1, 1, 2, 1))\n  mai <- par(\"mai\")\n  on.exit(par(op))\n  midx <- 0.5 * (xlim[2] + xlim[1])\n  xlim <- midx + (1 + tol) * 0.5 * c(-1, 1) * (xlim[2] - xlim[1])\n  midy <- 0.5 * (ylim[2] + ylim[1])\n  ylim <- midy + (1 + tol) * 0.5 * c(-1, 1) * (ylim[2] - ylim[1])\n  oldpin <- par(\"pin\") - c(mai[2] + mai[4], mai[1] + mai[3])\n  xuin <- oxuin <- oldpin[1]/diff(xlim)\n  yuin <- oyuin <- oldpin[2]/diff(ylim)\n  if (is.null(uin)) {\n    if (yuin > xuin) {\n      xuin <- yuin\n    } else {\n      yuin <- xuin\n    }\n  } else {\n    if (length(uin) == 1)\n      uin <- uin * c(1, 1)\n    if (any(c(xuin, yuin) < uin))\n      stop(\"uin is too large to fit plot in\")\n    xuin <- uin[1]\n    yuin <- uin[2]\n  }\n  xlim <- midx + oxuin/xuin * c(-1, 1) * diff(xlim) * 0.5\n  ylim <- midy + oyuin/yuin * c(-1, 1) * diff(ylim) * 0.5\n  \n  # generate breaks (petal boundaries) based on the widths\n  breaks <- (2*pi*c(0, cumsum(widths))/sum(widths))[-(n.petals+1)]\n  breaks <- c(breaks, 2 * pi)\n  plot(c(-1.2, 1.2), c(-1.2, 1.2), xlab=\"\", ylab=\"\", main=\"\",\n       xaxt=\"n\", yaxt=\"n\", pch=\" \", xlim=xlim, ylim=ylim,\n       bty=bty, ...)\n  title(main=main, ...)\n  \n  # plot full petal outlines\n  if (plot.outline) {\n    # note: go to n.petals not n.breaks because we the last break is\n    # the same as the first\n    for (i in 1:n.petals) {\n      lines(c(0, cos(breaks[i])), c(0, sin(breaks[i])), lty=lty)\n    }\n    circles(1, lty=lty)\n  }\n  # plot the petals themselves\n  if (is.null(fill.col)) {\n    fill.col <- rainbow(n.petals)\n  }\n  fill.col <- rep(fill.col, length.out=n.petals)\n  for (i in 1:n.petals) {\n    w1 <- breaks[i]\n    w2 <- breaks[i + 1]\n    rad <- radii[i]\n    xx <- rad * c(0, cos(w1), cos(w2), 0)\n    yy <- rad * c(0, sin(w1), sin(w2), 0)\n    polygon(xx, yy, xpd=FALSE, col=fill.col[i], border=fill.col[i])\n    lines(xx[1:2], yy[1:2])\n    lines(xx[3:4], yy[3:4])\n    circles(rad=rad, sector=c(w1, w2), fill=TRUE,\n            lty=1, col=fill.col[i], border=fill.col[i])\n  }\n  # plot petal labels, if given\n  if (!is.null(labels)) {\n    if (plot.outline) {\n      height <- label.offset + rep(1, n.petals)\n    } else {\n      height <- label.offset + radii\n    }\n    mids <- breaks[1:n.petals] + diff(breaks)/2\n    for (i in 1:n.petals) {\n      text(height[i] * cos(mids[i]), height[i] * sin(mids[i]),\n           labels=labels[i], cex=label.cex, \n           font=label.font, col=label.col)\n    }\n  }\n  \n  # add disk, if desired, with optional text in the middle\n  if (0 < disk) {\n    circles(disk, fill=TRUE, lty=1)\n  }\n  if (!is.null(center)) {\n    text(0, 0, labels=center, font=2, cex=2.2*cex)\n  }\n  invisible(NULL)\n}\n",
    "created" : 1500379098976.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3066763922",
    "id" : "8EFE61D0",
    "lastKnownWriteTime" : 1503666962,
    "last_content_update" : 1503666962128,
    "path" : "D:/tmp/DB_V1_LP/global.R",
    "project_path" : "global.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}